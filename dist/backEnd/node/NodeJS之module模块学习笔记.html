<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>【Node】NodeJS之module模块学习笔记</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.34d67128.css" as="style"><link rel="preload" href="/assets/js/app.269c0242.js" as="script"><link rel="preload" href="/assets/js/2.b3303c0a.js" as="script"><link rel="preload" href="/assets/js/20.950c0bcb.js" as="script"><link rel="prefetch" href="/assets/js/10.9551f909.js"><link rel="prefetch" href="/assets/js/11.9b9e5937.js"><link rel="prefetch" href="/assets/js/12.db1a0cbe.js"><link rel="prefetch" href="/assets/js/13.247701ca.js"><link rel="prefetch" href="/assets/js/14.a9daeff0.js"><link rel="prefetch" href="/assets/js/15.f0522486.js"><link rel="prefetch" href="/assets/js/16.079f82da.js"><link rel="prefetch" href="/assets/js/17.d12e8a36.js"><link rel="prefetch" href="/assets/js/18.58272faa.js"><link rel="prefetch" href="/assets/js/19.219431c0.js"><link rel="prefetch" href="/assets/js/21.b49ea422.js"><link rel="prefetch" href="/assets/js/22.28461d33.js"><link rel="prefetch" href="/assets/js/23.5eb75418.js"><link rel="prefetch" href="/assets/js/24.9ed9bb2d.js"><link rel="prefetch" href="/assets/js/25.e4baccc1.js"><link rel="prefetch" href="/assets/js/26.ba0c6f54.js"><link rel="prefetch" href="/assets/js/27.0b78fa78.js"><link rel="prefetch" href="/assets/js/28.46b339cb.js"><link rel="prefetch" href="/assets/js/29.24f804b2.js"><link rel="prefetch" href="/assets/js/3.0580c567.js"><link rel="prefetch" href="/assets/js/30.4518c0e9.js"><link rel="prefetch" href="/assets/js/31.a91e6cb8.js"><link rel="prefetch" href="/assets/js/32.537ab155.js"><link rel="prefetch" href="/assets/js/33.f3db2748.js"><link rel="prefetch" href="/assets/js/34.18afc3f7.js"><link rel="prefetch" href="/assets/js/35.0aa5b2c7.js"><link rel="prefetch" href="/assets/js/36.c573641d.js"><link rel="prefetch" href="/assets/js/37.97f89171.js"><link rel="prefetch" href="/assets/js/38.80529342.js"><link rel="prefetch" href="/assets/js/39.e1e52e00.js"><link rel="prefetch" href="/assets/js/4.22ace04f.js"><link rel="prefetch" href="/assets/js/40.e2ed85a1.js"><link rel="prefetch" href="/assets/js/41.a03d532b.js"><link rel="prefetch" href="/assets/js/42.5f4d7601.js"><link rel="prefetch" href="/assets/js/43.5caea9dd.js"><link rel="prefetch" href="/assets/js/44.890a8e09.js"><link rel="prefetch" href="/assets/js/45.e412252e.js"><link rel="prefetch" href="/assets/js/46.1d2592ea.js"><link rel="prefetch" href="/assets/js/47.71842b32.js"><link rel="prefetch" href="/assets/js/48.9ba46774.js"><link rel="prefetch" href="/assets/js/49.23e5abe7.js"><link rel="prefetch" href="/assets/js/5.6fca250f.js"><link rel="prefetch" href="/assets/js/50.c236b214.js"><link rel="prefetch" href="/assets/js/51.02234012.js"><link rel="prefetch" href="/assets/js/52.90a577bb.js"><link rel="prefetch" href="/assets/js/53.b8a05ab0.js"><link rel="prefetch" href="/assets/js/54.8ae1c14a.js"><link rel="prefetch" href="/assets/js/55.bfb13b97.js"><link rel="prefetch" href="/assets/js/56.fb04c1f8.js"><link rel="prefetch" href="/assets/js/57.0426c9db.js"><link rel="prefetch" href="/assets/js/58.57ca5a7c.js"><link rel="prefetch" href="/assets/js/59.6d0d6e28.js"><link rel="prefetch" href="/assets/js/6.41029863.js"><link rel="prefetch" href="/assets/js/60.568a60c9.js"><link rel="prefetch" href="/assets/js/61.c7528b24.js"><link rel="prefetch" href="/assets/js/62.4422c3f4.js"><link rel="prefetch" href="/assets/js/63.274686af.js"><link rel="prefetch" href="/assets/js/64.0ca9ea89.js"><link rel="prefetch" href="/assets/js/65.e7b757a0.js"><link rel="prefetch" href="/assets/js/66.03da0383.js"><link rel="prefetch" href="/assets/js/67.1d397d2f.js"><link rel="prefetch" href="/assets/js/68.79091aeb.js"><link rel="prefetch" href="/assets/js/69.4a09cae5.js"><link rel="prefetch" href="/assets/js/7.49b572ac.js"><link rel="prefetch" href="/assets/js/70.58a9ce18.js"><link rel="prefetch" href="/assets/js/71.f1f43dcb.js"><link rel="prefetch" href="/assets/js/72.8f359e1a.js"><link rel="prefetch" href="/assets/js/73.9f32edaf.js"><link rel="prefetch" href="/assets/js/74.34ab7ec3.js"><link rel="prefetch" href="/assets/js/75.4f0ec4fc.js"><link rel="prefetch" href="/assets/js/76.b44740db.js"><link rel="prefetch" href="/assets/js/77.9fb05ad7.js"><link rel="prefetch" href="/assets/js/78.959c29d0.js"><link rel="prefetch" href="/assets/js/79.af5a8dd1.js"><link rel="prefetch" href="/assets/js/8.45778cc9.js"><link rel="prefetch" href="/assets/js/80.28e02b2c.js"><link rel="prefetch" href="/assets/js/81.2f77bacc.js"><link rel="prefetch" href="/assets/js/82.ae55b51f.js"><link rel="prefetch" href="/assets/js/83.7f388dc3.js"><link rel="prefetch" href="/assets/js/84.bad4bf49.js"><link rel="prefetch" href="/assets/js/9.962dd750.js">
    <link rel="stylesheet" href="/assets/css/0.styles.34d67128.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="nodejs之module模块学习笔记"><a href="#nodejs之module模块学习笔记" class="header-anchor">#</a> NodeJS之module模块学习笔记</h1> <p><img src="E:%5Cblog%5Cimages%5Cnode%5Cnode-module.png" alt="module"></p> <h2 id="_1-module模块简介"><a href="#_1-module模块简介" class="header-anchor">#</a> 1.module模块简介</h2> <p>在NodeJS中，每个文件都被视为一个独立的模块。NodeJS默认支持<code>common.js</code>规范。</p> <blockquote><p><a href="https://juejin.im/post/5dfef166518825126131ce0f#heading-0" target="_blank" rel="noopener noreferrer">JavaScript模块化规范（CommonJs AMD CMD UMD ES6）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.im/entry/5ac83dff5188255c4c1084fd" target="_blank" rel="noopener noreferrer">结合源码分析 Node.js 模块加载与运行原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h2 id="_2-访问主模块"><a href="#_2-访问主模块" class="header-anchor">#</a> 2.访问主模块</h2> <p>当 Node.js 直接运行一个文件时， <code>require.main</code> 会被设为它的 <code>module</code>。 这意味着可以通过 <code>require.main === module</code> 来判断一个文件是否被直接运行：</p> <p>对于 <code>foo.js</code> 文件，如果通过 <code>node foo.js</code> 运行则为 <code>true</code>，但如果通过 <code>require('./foo')</code> 运行则为 <code>false</code>。</p> <p>因为 <code>module</code> 提供了一个 <code>filename</code> 属性（通常等同于 <code>__filename</code>），所以可以通过检查 <code>require.main.filename</code> 来获取当前应用程序的入口点。</p> <h2 id="_3-缓存"><a href="#_3-缓存" class="header-anchor">#</a> 3.缓存</h2> <p>模块是基于其解析的文件名进行缓存的。 由于调用模块的位置的不同，模块可能被解析成不同的文件名（比如从 <code>node_modules</code> 目录加载），这样就不能保证 <code>require('foo')</code> 总能返回完全相同的对象。</p> <p>此外，在不区分大小写的文件系统或操作系统中，被解析成不同的文件名可以指向同一文件，但缓存仍然会将它们视为不同的模块，并多次重新加载。 例如， <code>require('./foo')</code> 和 <code>require('./FOO')</code> 返回两个不同的对象，而不会管 <code>./foo</code> 和 <code>./FOO</code> 是否是相同的文件。</p> <h2 id="_4-核心模块"><a href="#_4-核心模块" class="header-anchor">#</a> 4.核心模块</h2> <p><code>require()</code> 总是会优先加载核心模块(核心模块定义在 Node.js 源代码的 <code>lib/</code> 目录下)。 例如， <code>require('http')</code> 始终返回内置的 HTTP 模块，即使有同名文件。</p> <h2 id="_5-循环加载"><a href="#_5-循环加载" class="header-anchor">#</a> 5.循环加载</h2> <p>当循环调用 <code>require()</code> 时，一个模块可能在未完成执行时被返回。</p> <p>例如以下情况:</p> <p><code>a.js</code>:</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a 开始'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
exports<span class="token punctuation">.</span>done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./b.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'在 a 中，b.done = %j'</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>
exports<span class="token punctuation">.</span>done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a 结束'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>b.js</code>:</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b 开始'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
exports<span class="token punctuation">.</span>done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'在 b 中，a.done = %j'</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>
exports<span class="token punctuation">.</span>done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b 结束'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>main.js</code>:</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main 开始'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./b.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'在 main 中，a.done=%j，b.done=%j'</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>done<span class="token punctuation">,</span> b<span class="token punctuation">.</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当 <code>main.js</code> 加载 <code>a.js</code> 时， <code>a.js</code> 又加载 <code>b.js</code>。 此时， <code>b.js</code> 会尝试去加载 <code>a.js</code>。 为了防止无限的循环，会返回一个 <code>a.js</code> 的 <code>exports</code> 对象的 <strong>未完成的副本</strong> 给 <code>b.js</code> 模块。 然后 <code>b.js</code> 完成加载，并将 <code>exports</code> 对象提供给 <code>a.js</code> 模块。</p> <p>当 <code>main.js</code> 加载这两个模块时，它们都已经完成加载。 因此，该程序的输出会是：</p> <div class="language-console extra-class"><pre class="language-text"><code>$ node main.js
main 开始
a 开始
b 开始
在 b 中，a.done = false
b 结束
在 a 中，b.done = true
a 结束
在 main 中，a.done=true，b.done=true
</code></pre></div><p>需要仔细的规划, 以允许循环模块依赖在应用程序内正常工作.</p> <h2 id="_6-文件模块"><a href="#_6-文件模块" class="header-anchor">#</a> 6.文件模块</h2> <p>如果按确切的文件名没有找到模块，则 Node.js 会尝试带上 <code>.js</code>、 <code>.json</code> 或 <code>.node</code> 拓展名再加载。</p> <p><code>.js</code> 文件会被解析为 JavaScript 文本文件， <code>.json</code> 文件会被解析为 JSON 文本文件。 <code>.node</code> 文件会被解析为通过 <code>process.dlopen()</code> 加载的编译后的插件模块。</p> <p>以 <code>'/'</code> 为前缀的模块是文件的绝对路径。 例如， <code>require('/home/marco/foo.js')</code> 会加载 <code>/home/marco/foo.js</code> 文件。</p> <p>以 <code>'./'</code> 为前缀的模块是相对于调用 <code>require()</code> 的文件的。 也就是说， <code>circle.js</code> 必须和 <code>foo.js</code> 在同一目录下以便于 <code>require('./circle')</code> 找到它。</p> <p>当没有以 <code>'/'</code>、 <code>'./'</code> 或 <code>'../'</code> 开头来表示文件时，这个模块必须是一个核心模块或加载自 <code>node_modules</code> 目录。</p> <p>如果给定的路径不存在，则 <code>require()</code> 会抛出一个 <code>code</code> 属性为 <code>'MODULE_NOT_FOUND'</code> 的 <a href="http://nodejs.cn/s/FLTm19" target="_blank" rel="noopener noreferrer"><code>Error</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h2 id="_7-从-node-modules-目录加载"><a href="#_7-从-node-modules-目录加载" class="header-anchor">#</a> 7.从 node_modules 目录加载</h2> <p>如果传递给 <code>require()</code> 的模块标识符不是一个<a href="http://nodejs.cn/api/modules.html#modules_core_modules" target="_blank" rel="noopener noreferrer">核心模块<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，也没有以 <code>'/'</code> 、 <code>'../'</code> 或 <code>'./'</code> 开头，则 Node.js 会从当前模块的父目录开始，尝试从它的 <code>/node_modules</code> 目录里加载模块。 Node.js 不会附加 <code>node_modules</code> 到一个已经以 <code>node_modules</code> 结尾的路径上。</p> <p>如果还是没有找到，则移动到再上一层父目录，直到文件系统的根目录。</p> <p>例子，如果在 <code>'/home/ry/projects/foo.js'</code> 文件里调用了 <code>require('bar.js')</code>，则 Node.js 会按以下顺序查找：</p> <ul><li><code>/home/ry/projects/node_modules/bar.js</code></li> <li><code>/home/ry/node_modules/bar.js</code></li> <li><code>/home/node_modules/bar.js</code></li> <li><code>/node_modules/bar.js</code></li></ul> <p>这使得程序本地化它们的依赖，避免它们产生冲突。</p> <p>通过在模块名后包含一个路径后缀，可以请求特定的文件或分布式的子模块。 例如， <code>require('example-module/path/to/file')</code> 会把 <code>path/to/file</code> 解析成相对于 <code>example-module</code> 的位置。 后缀路径同样遵循模块的解析语法。</p> <h2 id="_8-模块封装器"><a href="#_8-模块封装器" class="header-anchor">#</a> 8.模块封装器</h2> <p>在执行模块代码之前，Node.js 会使用一个如下的匿名函数封装器将其封装：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">exports<span class="token punctuation">,</span> require<span class="token punctuation">,</span> module<span class="token punctuation">,</span> __filename<span class="token punctuation">,</span> __dirname</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 模块的代码实际上在这里</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>通过这样做，Node.js 实现了以下几点：</p> <ul><li>它保持了顶层的变量（用 <code>var</code>、 <code>const</code> 或 <code>let</code> 定义）作用在模块范围内，而不是全局对象。</li> <li>它有助于提供一些看似全局的但实际上是模块特定的变量，例如：
<ul><li>实现者可以用于从模块中导出值的 <code>module</code> 和 <code>exports</code> 对象。</li> <li>包含模块绝对文件名和目录路径的快捷变量 <code>__filename</code> 和 <code>__dirname</code> 。</li></ul></li></ul> <h2 id="_9-模块作用域"><a href="#_9-模块作用域" class="header-anchor">#</a> 9.模块作用域</h2> <h3 id="_9-1-dirname和-filename当前模块的目录名"><a href="#_9-1-dirname和-filename当前模块的目录名" class="header-anchor">#</a> 9.1 <code>__dirname</code>和<code>__filename</code>当前模块的目录名</h3> <p>与 <a href="http://nodejs.cn/s/RH6qCV" target="_blank" rel="noopener noreferrer"><code>__filename</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的 <a href="http://nodejs.cn/s/7t4KCq" target="_blank" rel="noopener noreferrer"><code>path.dirname()</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 相同。</p> <p>示例，从 <code>/Users/mjr</code> 运行 <code>node example.js</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 打印: /Users/mjr</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>__filename<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 打印: /Users/mjr</span>
</code></pre></div><h3 id="_9-2-exports-快捷方式"><a href="#_9-2-exports-快捷方式" class="header-anchor">#</a> 9.2 exports 快捷方式</h3> <p><code>exports</code> 变量是在模块的文件级作用域内可用的，且在<strong>模块执行之前</strong>赋值给 <code>module.exports</code>。</p> <p>它允许使用快捷方式，因此 <code>module.exports.f = ...</code> 可以更简洁地写成 <code>exports.f = ...</code>。 但是，就像任何变量一样，如果为 <code>exports</code> 赋予了新值，则它将不再绑定到 <code>module.exports</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>hello <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 从模块的引用中导出。</span>
exports <span class="token operator">=</span> <span class="token punctuation">{</span> hello<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 不导出，仅在模块中可用。</span>
</code></pre></div><p>当 <code>module.exports</code> 属性被新对象完全替换时，通常也会重新赋值 <code>exports</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... </span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>为了说明这种行为，想象对 <code>require()</code> 的假设实现，它与 <code>require()</code> 的实际实现非常类似：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token punctuation">{</span> exports<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">module<span class="token punctuation">,</span> exports</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模块代码在这。在这个例子中，定义了一个函数。</span>
    <span class="token keyword">function</span> <span class="token function">someFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    exports <span class="token operator">=</span> someFunc<span class="token punctuation">;</span>
    <span class="token comment">// 此时，exports 不再是一个 module.exports 的快捷方式，</span>
    <span class="token comment">// 且这个模块依然导出一个空的默认对象。</span>
    module<span class="token punctuation">.</span>exports <span class="token operator">=</span> someFunc<span class="token punctuation">;</span>
    <span class="token comment">// 此时，该模块导出 someFunc，而不是默认对象。</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_9-3-module对象"><a href="#_9-3-module对象" class="header-anchor">#</a> 9.3 <code>module</code>对象</h3> <ul><li><p><code>module.children</code>：&lt;module[]&gt;  被该模块引用的模块对象。</p></li> <li><p><code>module.exports</code>: <object><code>module.exports</code> 对象由 <code>Module</code> 系统创建。</object></p></li> <li><p><code>module.filename</code>: <string>模块的完全解析后的文件名。</string></p></li> <li><p><code>module.id</code>: <string>模块的标识符。 通常是完全解析后的文件名。</string></p></li> <li><p><code>module.loaded</code>：<boolean>模块是否已经加载完成，或正在加载中。</boolean></p></li> <li><p><code>module.parent</code>: <moduls>最先引用该模块的模块。</moduls></p></li> <li><p><code>module.paths</code>: &lt;string[]&gt;模块的搜索路径。</p></li> <li><p><code>module.require(id)</code>: id<string>, 返回: <a href="http://nodejs.cn/s/6sTGdS" target="_blank" rel="noopener noreferrer"><any><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></any></a> 导出的模块内容。</string></p></li> <li><p><code>module.require()</code> 方法提供了一种加载模块的方法，就像从原始模块调用 <code>require()</code> 一样。</p> <p>为了做到这个，需要获得一个 <code>module</code> 对象的引用。 因为 <code>require()</code> 会返回 <code>module.exports</code>，且 <code>module</code> 通常只在一个特定的模块代码中有效，所以为了使用它，必须显式地导出。</p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.269c0242.js" defer></script><script src="/assets/js/2.b3303c0a.js" defer></script><script src="/assets/js/20.950c0bcb.js" defer></script>
  </body>
</html>
